[#rfc:federation:data-sync]
= Data Sync

[NOTE]
====
The Origin and Destination nodes are referred to the point of Origin of data as in the sharer of the information, as opposed to the Destination node, the destination of the sent information. See more in <<rfc:federation:data-sync:origin, Glossary>>.
====

The data sync occurs after the first two phases, node authentication and pairing, and structure sync are successfuly done. The orchestrator for the data sync is a federation data sync service that works with the compose API service and store repository methods. The structure of the microservice works in a way as to possibly decouple the service from the main corteza server.

Once the structure sync is successfuly done (before each data sync starts), the data sync commences. First, it needs to fetch the master changes list, which lists the endpoints of all the modules whose records were either deleted, updated or created during the time window since the last successful data sync.

After the Federation Service fetches the master list, the data sync is started for each of the modules. More is described in the <<rfc:federation:data-sync:origin,Flow from the Origin node aspect>> and <<rfc:federation:data-sync:destination,Flow from the Destination node aspect>>.

[#rfc:federation:data-sync:origin]
== Data sync (Origin)

=== Data sync diagram
[source,uml]
----
@startuml
skinparam responseMessageBelowArrow true
actor "Destination Node" as NodeDestination

box "Origin Node" #f7f7f7

participant "Federation Rest Controller" as FRestController
participant "Federation Service" as FederationService
participant "Compose Record Service" as ComposeRS
database Store
participant "Federation Data Service" as FDataService
participant Encoder

NodeDestination -> FRestController: get data
note left : only the data\nthat was updated after\nlast successful sync
activate FRestController

FRestController -> FederationService: get all records for a specific module
activate FederationService

FederationService -> Store: get federation info on module and mapped fields

activate Store
Store -> FederationService: federation mappings
deactivate Store

FederationService -> ComposeRS: get filtered compose Records for Module

activate ComposeRS
ComposeRS -> Store: get filtered records

activate Store
Store -> ComposeRS: list of compose Records
deactivate Store

ComposeRS -> FederationService: list of compose Records
deactivate ComposeRS

FederationService -> FDataService: prepare the record list with specific fields
note left : omit the fields we do not wish to share
activate FDataService
FDataService -> FederationService: list with specific fields
deactivate FDataService

FederationService -> Encoder: transform the list to specific structure

activate Encoder
Encoder -> FederationService: transformed list
deactivate Encoder

FederationService -> FRestController: transformed list of data
deactivate FederationService

FRestController -> NodeDestination: list of records
deactivate FRestController

end box
@enduml
----

.*Sharing federated data on the Origin node*:
1. The incoming request from Destination is parsed and the input parameters about module and 
last update time is provided to the Federation service
2. The federation service calls the Federation Data Service, which in turn first fetches all the federation info about the 
module and the fields mappings
3. Once the info is gathered from the store, the Federation Data Service fetches the compose Records from store
4. All the records are then transformed in the service to include only the necessary data (also the specific fields and the paging data)
5. Once the list is generated, it is sent to the exporter service to transform the list to the appropriate standard
6. Alongside the list, there is also the filtering info with the paging data, so any necessary requests are made again
to satisfy the length of the data (paging) and to ensure all the data is not fetched in one big chunk

[#rfc:federation:data-sync:destination]
== Data sync (Destination)

=== Data sync diagram
[source,uml]
----
@startuml
skinparam responseMessageBelowArrow true
actor "Origin Node" as NodeOrigin

box "Destination Node" #f7f7f7

participant "Federation Service" as FederationService
participant "Compose Record Service" as ComposeRS
database Store
participant "Federation Data Service" as FDataService
participant Decoder

activate FederationService
FederationService -> NodeOrigin: get federated records for module
activate NodeOrigin
NodeOrigin -> FederationService: list of federated records
deactivate NodeOrigin

FederationService -> Store: get federation info on module and mapped fields

activate Store
Store -> FederationService: federation mappings
deactivate Store

FederationService -> Decoder: list of records in specific format
note right: this is the transport structure\n coming from Origin Node
activate Decoder
Decoder -> FederationService: list of records
deactivate Decoder

FederationService -> FDataService: records + federation mappings
activate FDataService
FDataService -> FederationService: list of compose Records
deactivate FDataService

FederationService -> ComposeRS: list of records with appropriate fields
activate ComposeRS
ComposeRS -> Store: write records to compose storage

activate Store
Store -> ComposeRS: status
deactivate Store

ComposeRS -> FederationService: status
deactivate ComposeRS

FederationService -> Store: set sync status
deactivate FederationService
end box
@enduml
----

.*Fetching shared federated data to the Destination node*:
1. Start the data sync after a successful structure sync is done
2. Data sync service checks for the last successful sync date in store
3. The latest data changes are fetched from the Origin (depending on the last sync)
4. The list of url endpoints is provided on the Origin
5. Destination parses the list of endpoints and fetches the corresponding records per-federation module
6. Destination node gets the mapping info via Federation Service from the Store
7. The federation info and the list of records are transformed in the Federation Data Service
to accomodate the field mappings
8. The list of records are then written to the Store via compose service
9. After the successful data sync, the federation status is saved as successful for the future sync
