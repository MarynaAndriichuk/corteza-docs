[#rfc:federation:structure-sync]
= Structure sync

== Structure sync (Origin)

Structure sync starts when both of the nodes are already paired and ready to receive data.

=== Structure sync diagram
[source,uml]
----
@startuml
skinparam responseMessageBelowArrow true
hide footbox

actor "Destination Node" as NodeDestination

box "Origin Node" #f7f7f7

participant "Federation Rest Controller" as FRestController
participant "Federation Service" as FederationService
participant "Compose Module Service" as ComposeMS
database Store
participant "Federation Structure Service" as FStructureService
participant Encoder

NodeDestination -> FRestController: get structure
note left : only the structure\nthat was updated after\nlast successful sync
activate FRestController

FRestController -> FederationService: get structure for all modules
activate FederationService

FederationService -> Store: get module id list

activate Store
Store -> FederationService: federated modules id list
deactivate Store

FederationService -> ComposeMS: get filtered compose Modules

activate ComposeMS
ComposeMS -> Store: get filtered list of modules

activate Store
Store -> ComposeMS: list of compose Modules
deactivate Store

ComposeMS -> FederationService: list of compose Modules
deactivate ComposeMS

FederationService -> FStructureService: module list + federated module ID list + federated field ID list
note left : omit the fields we do not wish to share
activate FStructureService
FStructureService -> FederationService: module list with specific fields
deactivate FStructureService

FederationService -> Encoder: transform the list to specific structure

activate Encoder
Encoder -> FederationService: transformed list
deactivate Encoder

FederationService -> FRestController: transformed list of modules (structure)
deactivate FederationService

FRestController -> NodeDestination: list of modules
deactivate FRestController

end box
@enduml
----


.Sharing structure on the Origin node:
1. Starting with no information regarding the federated modules on node A, node B makes a request for the structure list
2. Node A serves the list of federated module endpoints
3. Node B parses the endpoints and starts to sync the structure data per-module by calling each of the endpoints in the master list
4. Node A serves the module details by fetching the federation info from store, module info via compose (from store) and filters the list to the end structure of choice (for now - json compose.Record)
5. Once the node B fetches the list, it stores the information to the federation store
6. Once the structure sync is done, the federation sync status is written to the store, along with the date of the action (needed by the data sync)

== Structure sync (Destination)

=== Structure sync diagram
[source,uml]
----
@startuml
skinparam responseMessageBelowArrow true
hide footbox

actor "Destination Node" as NodeOrigin

box "Origin Node" #f7f7f7

participant "Federation Service" as FederationService
participant "Compose Module Service" as ComposeMS
database Store

NodeOrigin -> FederationService: get structure
note left : list of federated Modules\nfrom phase I
activate FederationService

FederationService -> Store: write federated modules and fields info
FederationService -> Store: structure sync OK

deactivate FederationService

end box
@enduml
----

.Sharing structure on the Destination node:
1. Destination node (node B) sends a request to node A for the structural changes (/federation/structure)
2. Node A goes through the first phase (structure sync part 1) and serves the list of structures for all modules
3. Node B receives the list of endpoints and for each of the upstreamed modules (from node A), requests the specific endpoint for the federated module (/federation/structure/module/{id})
4. Node B parses the response from node A and writes the module and field data to the store
5. Note - only the module and field basic info is stored at this point - no compose.Module is created yet!
6. Once the module/field meta is saved to the federation store, the structure sync operation is marked as done for the node A/node B duo
7. Once the structure sync operation is done, the structure mapping on node A or data sync (even if no structure is mapped) can be commenced

== Field mapping on Destination

The custom field mapping is done via a json payload in the *federation_module_mapping* and *federation_module_exposed* tables.

=== Exposed payload

These are the fields that are exposed on the Origin. During the sync, these fields are fetched from compose DB via name (unique) and added to the structure payload along with the module info.

[source,json]
----
[
    {
        "name": "<origin_compose_module_field_name>",
        "label": "<origin_compose_module_field_label>",
        "kind": "<origin_compose_module_field_kind>",
        "is_multi": "<origin_compose_module_field_is_multi>"
    }
]
----


=== Mapping payload

These are the fields that are synced from the Origin on the Destination and mapped via a designated UI (or not) in the DB.

[source,json]
----
[
    {
        "origin": {
            "name": "<origin_compose_module_field_name>",
            "kind": "<origin_compose_module_field_kind>",
            "is_multi": "<origin_compose_module_field_is_multi>"
        },
        "destination": {
            "name": "<destination_compose_module_field_name>",
            "kind": "<destination_compose_module_field_kind>",
            "is_multi": "<destination_compose_module_field_is_multi>"
        }
    }
]
----

== Examples

*Module _Account_*

=== Phase I - on Origin node

First phase is exposing the desired modules for a specific node (to the Destination), so the structure mapping on the Destination and then the data sync can be done.

*compose_module*
|===
|id|handle|name

|161250629010849793|Account|Account
|===

*compose_module_field*
|===
|id|kind|name|label|is_multi

| 161250629061509121 | String | Phone              | Phone                |        0
| 161250629027758081 | Url    | LinkedIn           | LinkedIn             |        0
| 161250629044666369 | String | Description        | Description          |        0
|===

*federation_node*
|===
|id|name

|1|Origin server
|2|Destination server
|===

*federation_module_exposed*
|===
|id|rel_node|rel_compose_module|field_mapping

|11|2|161250629010849793|[{"name":"Phone","kind":"String","is_multi":0}]
|===

=== Phase II - on Destination node

There are 2 phases in the phase II. First the module info from Origin is saved. After that we can do the mapping. The modules on the Destination need to be created beforehand.

*compose_module*
|===
|id|handle|name

|261250629010849755|Account_federated|Account (federated from Origin)
|===

*compose_module_field*
|===
|id|kind|name|label|is_multi

| 161250629061509121 | String | Mobile      | Mobile               |        0
| 161250629044666369 | String | Desc        | Description          |        0
|===

*federation_node*
|===
|id|name

|1|Our server
|2|Misc server (some other server)
|3|Origin server in this example (from phase I)
|===

==== 1. Fetch and save the module info

*federation_module_shared*

|===
|id|handle|name|rel_node|xref_module|field_mapping

|22|Account|Account|3|11|[{"name":"Phone","kind":"String","is_multi":0}]
|===

==== 2. Mapping finished, modules created

The sharing of modules info from Origin is added, that is enough information for us to handle mapping from UI. We can now pick the fields from the field_mapping column that we need and store it into the mapping table.

*federation_module_mapping*

|===
|federation_module_id|compose_module_id|fields

|22|261250629010849755|[{"origin":{"name":"Phone","kind":"String","is_multi":0},"destination":{"name":"Mobile","kind":"String","is_multi":0}}]
|===
