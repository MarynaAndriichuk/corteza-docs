[#rfc:federation:structure-sync]
= Structure sync

== Structure sync part I - serve upstream modules on source node

Structure sync starts when both of the nodes are already paired and ready to receive data.

.Flow:
1. Starting with no information regarding the federated modules on node A, node B makes a request for the structure list
2. Node A serves the list of federated module endpoints
3. Node B parses the endpoints and starts to sync the structure data per-module by calling each of the endpoints in the master list
4. Node A serves the module details by fetching the federation info from store, module info via compose (from store) and filters the list to the end structure of choice (for now - json compose.Record)
5. Once the node B fetches the list, it stores the information to the federation store
6. Once the structure sync is done, the federation sync status is written to the store, along with the date of the action (needed by the data sync)

image:../images/federation_structure_sync.jpg[Diagram of the structure sync action as seen from node A]

== Structure sync part II - fetch modules on destination node (from source node)

.Flow:
1. Destination node (node B) sends a request to node A for the structural changes (/federation/structure)
2. Node A goes through the first phase (structure sync part 1) and serves the list of structures for all modules
3. Node B receives the list of endpoints and for each of the upstreamed modules (from node A), requests the specific endpoint for the federated module (/federation/structure/module/{id})
4. Node B parses the response from node A and writes the module and field data to the store
5. Note - only the module and field basic info is stored at this point - no compose.Module is created yet!
6. Once the module/field meta is saved to the federation store, the structure sync operation is marked as done for the node A/node B duo
7. Once the structure sync operation is done, the structure mapping on node A or data sync (even if no structure is mapped) can be commenced

image:../images/federation_structure_sync_phase2.jpg[Diagram of the structure sync action as seen from node B]

== Endpoints

[cols="~,~,~"]
|===
|Action| Endpoint |Description

3+|*CRUD endpoints*
|GET     |/nodes/{nodeID}/modules?exposed               |list of federated modules that are shared to the other node
|GET     |/nodes/{nodeID}/modules?shared                |list of federated modules that are shared by other node
// |GET     |/nodes/{nodeID}/modules/{f-moduleID-A}        |????dodaj spec. modul v federation????
|POST    |/nodes/{nodeID}/modules/{f-moduleID-A}        |dodaj spec. modul v federation
|DELETE  |/nodes/{nodeID}/modules/{f-moduleID-A}        |remove federated module (from sharing)
|GET     |/nodes/{nodeID}/modules/{f-moduleID-A}/exposed|federated module info (with fields) - sharing to the other node
|PUT     |/nodes/{nodeID}/modules/{f-moduleID-A}/exposed|change sharing settings of a federated module (fields we share to other node)
|GET     |/nodes/{nodeID}/modules/{f-moduleID-B}/shared |federated module info (with fields) of the shared module from other node
|GET     |/nodes/{nodeID}/modules/{f-moduleID-B}/mapped |mapping settings for a federated modules
|PUT     |/nodes/{nodeID}/modules/{f-moduleID-B}/mapped |set mapping for a federated module
|DELETE  |/nodes/{nodeID}/modules/{f-moduleID-B}/mapped |revoke mapping, cancel record sync 
3+|*Sync endpoints*
|GET|/exposed/modules                              |get a list of federated modules (changes on the originating node)
|GET|/exposed/modules/{f-moduleID}                 |get the shared federated module structure (with fields, per-node)
|GET|/exposed/modules/{f-moduleID}/records         |get the records of a federated module
|GET|/exposed/users/                               |TBD
|===

== Field mapping on Destination

The custom field mapping is done via a json payload in the *federation_module_mapping* and *federation_module_exposed* tables.

=== Exposed payload

These are the fields that are exposed on the Origin. During the sync, these fields are fetched from compose DB via name (unique) and added to the structure payload along with the module info.

[source,json]
----
[
    {
        "name": "<origin_compose_module_field_name>",
        "kind": "<origin_compose_module_field_kind>",
        "is_multi": "<origin_compose_module_field_is_multi>"
    }
]
----


=== Mapping payload

These are the fields that are synced from the Origin on the Destination and mapped via a designated UI (or not) in the DB.

[source,json]
----
[
    {
        "origin": {
            "name": "<origin_compose_module_field_name>",
            "kind": "<origin_compose_module_field_kind>",
            "is_multi": "<origin_compose_module_field_is_multi>"
        },
        "destination": {
            "name": "<destination_compose_module_field_name>",
            "kind": "<destination_compose_module_field_kind>",
            "is_multi": "<destination_compose_module_field_is_multi>"
        }
    }
]
----


== DB

=== federation_module_exposed
|===
|Column |Description

|id|federation module id
|rel_node|node id (destination node id - who are we sharing to)
|rel_compose_module|module id on source node
|fields|list of fields
|===

=== federation_module_shared
|===
|Column |Description

|id|federation module id
|handle|Module handle
|name|Module name
|rel_node|node id (source node id - who is sharing with us)
|xref_module|federation module id on source node (id in federation_module_exposed)
|fields|list of fields
|===

=== federation_module_mapping
|===
|Column |Description

|federation_module_id|id from federation_module_downstream
|compose_module_id|existing module
|field_mapping|json field mappings, ex: [{ source: 'node_A_module_field_7', dest: 'node_B_module_field_2', transform: 'string' }]
|===

== Examples

*Module _Account_*

=== Phase I - on Origin node

First phase is exposing the desired modules for a specific node (to the Destination), so the structure mapping on the Destination and then the data sync can be done.

*compose_module*
|===
|id|handle|name

|161250629010849793|Account|Account
|===

*compose_module_field*
|===
|id|kind|name|label|is_multi

| 161250629061509121 | String | Phone              | Phone                |        0
| 161250629027758081 | Url    | LinkedIn           | LinkedIn             |        0
| 161250629044666369 | String | Description        | Description          |        0
|===

*federation_node*
|===
|id|name

|1|Origin server
|2|Destination server
|===

*federation_module_exposed*
|===
|id|rel_node|rel_compose_module|fields

|11|2|161250629010849793|[{"name":"Phone","kind":"String","is_multi":0}]
|===


=== Phase II - on Destination node

There are 2 phases in the phase II. First the module info from Origin is saved. After that we can do the mapping. The modules on the Destination need to be created beforehand.

*compose_module*
|===
|id|handle|name

|261250629010849755|Account_federated|Account (federated from Origin)
|===

*compose_module_field*
|===
|id|kind|name|label|is_multi

| 161250629061509121 | String | Mobile      | Mobile               |        0
| 161250629044666369 | String | Desc        | Description          |        0
|===

*federation_node*
|===
|id|name

|1|Our server
|2|Misc server
|3|Origin server in this example (from phase I)
|===

==== 1. Fetch and save the module info

*federation_module_shared*

|===
|id|handle|name|rel_node|xref_module|fields

|22|Account|Account|3|11|[{"name":"Phone","kind":"String","is_multi":0}]
|===


==== 2. Mapping finished, modules created

The sharing of modules info from Origin is added, that is enough information for us to handle mapping from UI. We can now pick the fields from the field_mapping column that we need and store it into the mapping table.

*federation_module_mapping*

|===
|federation_module_id|compose_module_id|field_mapping

|22|261250629010849755|[{"origin":{"name":"Phone","kind":"String","is_multi":0},"destination":{"name":"Mobile","kind":"String","is_multi":0}}]
|===
