include::../../variables.adoc[]

= Key-based pagination

With version `2020.12` {PRODUCT_NAME} moved away from offset pagination to the *key-based* pagination.

== Quick explanation of offset-based pagination

Pagination is done with one of the two parameter pairs: `limit` and `offset` or `page` and `per page`.
When a specific page is requested a simple formula is used (`per page` * `page`) to calculate the offset parameter.
This parameter is then used to fetch results from the database.
Database always starts with the 1st row, checks it and if can be returned (offset=0) it skips it.
If offset is set to 100 then this step is repeated 100-times and with offset = 100k, it is repeated 100k-times.

WARNING: From `2020.12` on, this is no longer supported.

== Key-based pagination

This is also known as pagination with relative cursors.
We are operating with `limit` and `page cursor` parameters and with `next page` and `prev page` cursor values.
Cursor values are opaque. Changing internal values could lead to empty result pages.
Cursor is created from the first and last item in the returned set with some extra attributes that aids its internal process.

Sorting also has a major effect on how cursors values are collected.
System needs to know about direction of data and all keys used in the sorting.

For example, if data is sorted by `column-one` and `id`, cursor for the next page contains values for both these fields from the first and last item in the returned set.
When using the cursor for the next page, only items with values greater than the one from `column-one` and `id` are returned.

In general, all resources are sorted by the primary-key, ascending. That also provides the most optimal performance.

When request with a `limit` parameter is made, {PRODUCT_NAME} collects as many items as possible to fulfill that limit.
If there are fewer items than the requested limit, `next page` cursor is not returned.
If `page cursor` is used, system knows that it's serving non-first page.


=== Performance
With key-based pagination (when index are used optimally) response is in most cases fixed.
That means that even if you request results from the 1000th page response time is within the same magnitude as for the 1st page.

=== Filtering
Resource collecting code is written in the way that it can perform multiple fetches to the database until it fills the whole page.
This is needed in cases when application level filtering (security) removes items from the result set.

Handling pagination with relative cursor means we can skip as many items as required on a database or application level.
In practice this means that extra (dynamic) security constraints can be applied when accessing resources.

== Handicapped page navigation and counting total items
With relative cursors, it's currently not possible to jump on a specific page.
Only moving back to 1st page is possible or accessing the last page with reverting the sort or order.

While page navigation is technical possible it might result in a decreased performance.
Similar issues are with generating number total items that can be returned.

Both this issues might be solved in future release provided with the result set when explicitly requested.

