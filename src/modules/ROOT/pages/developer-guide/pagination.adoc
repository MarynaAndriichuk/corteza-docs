include::../../variables.adoc[]

= Pagination

With version `2020.12` {PRODUCT_NAME} moved away from offset pagination to the *key-based* pagination.

== Offset-based pagination

[IMPORTANT]
====
From `2020.12` on, this is *no longer supported*.
====

Pagination is done with two parameters: `page` and `per page` (sometimes `offset` and `limit`).
When a specific page is requested, a simple formula is used (`per page * page`) to calculate the offset parameter.
This parameter is then used to fetch results from the database.

The database always starts with the 1st row, checks it and if can be returned (offset=0) it skips it.
If the offset is 100, this step is repeated 100-times; if the offset is 100k, this step is repeated 100k-times.

== Key-based pagination

[TIP]
====
Also known as pagination with relative cursors.
====

[IMPORTANT]
====
Cursor values are *opaque*; changing internal values *could lead to anomalies*, such as empty results.
====

We are working with `limit`, `next page`, and `prev page` cursors.
The cursor gets calculated from the *first* and the *last* item in the returned set of resources.
The cursor receives some additional metadata (used *indexes* and *sorting direction*).

When fetching the next page, only the items with greater values are returned; when fetching the previous page, only the items with lesser values are returned.

For example, if we *sort the data* by `column-one` and `id`, the cursor for the *next page* contains values for both fields from the *last item*; the cursor for the *previous page* includes values for both fields from the *first item*.

When we request a *limited set of resources* (we provide a `limit` parameter), the system *collects as many items* as possible to *fulfil that limit*.

.The page cursors are provided in the response:
* If the resulting set has fewer items then the requested limit, the *next page* cursor is omitted.
* If the *page cursor* parameter is *not provided*, we are accessing the *first page*, so the *previous page* cursor is omitted.

[NOTE]
====
In general, all resources are sorted by the primary-key, ascending (this also provides the most optimal performance).
====

=== Performance

With key-based pagination (when index are used optimally) response times (for most cases) remain *consistent* -- the access time for the *n-th page* is the same as the access time for the *1st page*.

[NOTE]
====
*DevNote* provide some references, benchmarks, ...
====

=== Collecting resources

Resource collecting code is written in the way that it can *perform multiple fetches* to the database until it *satisfies the page*.
This is needed in cases when *application-level filtering* (security) *removes items* from the result set.

This allows us to implement *additional security logic* on the application level when accessing resources.

== _Handicapped page navigation and item counting_

With relative cursors, it's currently *not possible* to jump on a *specific page* -- only *next page*, *previous page*, *back to the 1st-page*, and *go to the last page* (reversed sort) are possible.
Similar issues are with generating the *total number of items* in the dataset.

We will attempt to address both issues in future releases.

[NOTE]
====
Page navigation is technically possible, but it might result in decreased performance.
====
