= Git workflow in Corteza projects

== Terminology
Major version::
Corteza does major releases by end of each quarter, in last weeks March, June, September and December.
This versions are prefixed with full year and quarter number (`YYYY.Q`), for example `2020.12` for last release in 2020 .
Major version is also referred to as "release".

Version branch::
When preparing changes for next mayor version, developers use version, suffixed with a `.x`, for example `2021.3.x`.
Branch is created as soon as new features, scheduled for that release start coming and is kept forever.

Feature branch::
Feature branches are short lived branches, prefixed with version branch and suffixed with short description of the feature: `YYYY.Q.x-feature-<description>`, for example: `2021.3.x-feature-workflow`.

Prefixing feature with version helps us navigate and reduces confusion when feature is merged into version branch.

Release::
When version is ready to be released a **git tag** is created on the stable commit.
Release tags are always in `YYYY.Q.R` where R is an incremental number of the release, starting with 0, for example `2021.3.0`.

Patch release::
After a series of changes and fixes in the version branch, a patch release can be tagged.
A release is every release with release number greater than 0.
`2021.3.0` is first release and `2021.3.1`, `2021.3.2`, ... are patch releases.

Patch release is usually referred to as just "release".

Release Candidate (RC)::
Before doing a release or a patch release, one or more release candidates can be created on a version branch.
Release candidate is created by tagging a commit with `YYYY.Q.R-rc.C` where C is an incremental number of the release.
Numbers starts with 0.
RC version example: `2021.3.0-rc.3`.

Version::
When using to "version" we refer to any of the terms above: release, feature, version branch, patch release or release candidate

== Where to start

Get familiar with git superpowers!
Get to know about rebase, interactive rebase, cherry-picking, fast-forward merging and using reflog.
Learn how to stash, squash and hard reset to mold your commits into a perfectly written story.

Just looking around?
It's best if you do that on the last stable release.

Fixing a bug?
Try to find out the version where that bug is causing issues and start there

Working on a new feature?
Start with the "bleeding-edge" and checkout branch where the next release is getting ready.

== Arguments against use of Git Flow in Corteza git repositories

Gitflow is a nice idea, and it looks clean and tidy on paper.
It abandons rebasing and makes project (git) history completely unreadable after a couple of merges.

== Arguments against `master`/`main` branches in Corteza git repositories

_From this point on I'm using main for all variants of what was previously known as `master` branch_

Keeping changes inside `main` branch makes it difficult to know what version you are working with.
It also makes it difficult to know what version you're merging changes in.

== Arguments for moving default branch on GitHub

GitHub (in contrast to Git) has a concept of a default branch.
This means it will checkout whatever it is set as a default branch when not defining it explicitly

When releasing, we reconfigure default branches on all repositories to point the next version branch.
This allows (new) engineers to start with the correct branch instead of accidentally wasting time on an old code.

== Rebasing and cleaning up feature branch before merge

Each feature branch should be frequently rebased with changes from the originating branch.
This will minimize diff and code-review noise.
Resolving smaller chunks of conflicts on each rebase will minimize of not remove the chance conflicts on merge.

Do not be afraid to deconstruct and reconstruct the entire feature branch to get to create simpler commits and a cleaner history.
Commits should tell a story and allow the reviewer (also, yourself in the future) to understand what has happened.

If entire feature results in a single commits of a couple of hundred lines, that is ok too.

== Merging feature branches

After feature branch is rebased, commits cleaned and all changes reviewed it needs to be merged.
One or two commits usually do not call for non-forwarding merge (without a merge commit, commits from the feature branch are placed on to of the version branch's HEAD). If a change is severe and needs to pop up when reviewing history or there are more commits to be merged, always use a non-forwarding merge.

IMPORTANT: Always make sure to rebase your feature branch before you merge!

IMPORTANT: Clean up after yourself and delete the feature branch after it is merged.

== Rebasing version branches

For first weeks after major version is released you can expect that branch for the next version is regularly rebased.
This allows us to defer branch diverging through first batches of post-release fixes and patches.
When bigger changes starts coming to the new version, rebasing usually stops.

== Renaming feature branches
When feature branches is delayed and slides into next release, branch is renamed and old version is replaced with the new one.
For example, we "schedule" feature foo for end of the 2020 by putting it into a branch `2020.12.x-feature.foo`.
Sometimes plan go south and work gets delayed.
And decision is made that foo will be part of March release and we rename the branch to `2021.3.x-feature.foo`.

== Committing directly on version branch

Features and fixes do not need to go through branching and merging process.
As long as changes are smaller and contained into one or two commits, changes can be applied directly to version branch.

== Patching version branches

When fixing a bug or introducing a small improvement for released versions.
This patch should be contained in a single commit with a clear and descriptive commit message.

This commit is then applied across all relevant branches with `cherry-pick` command.
